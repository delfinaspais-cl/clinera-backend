import { Injectable, ConflictException, BadRequestException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { UpdateProfileDto } from './dto/update-profile.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { CreateUserDto } from './dto/create-user.dto';
import { PermissionsService } from './services/permissions.service';
import { MensapiIntegrationService } from './services/mensapi-integration.service';
import { EmailService } from '../email/email.service';
import { PasswordGenerator } from '../common/utils/password-generator';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(
    private prisma: PrismaService,
    private mensapiIntegration: MensapiIntegrationService,
    private emailService: EmailService,
  ) {}

  findAll() {
    return this.prisma.user.findMany();
  }

  async findMe(userId: string) {
    return this.prisma.user.findUnique({
      where: { id: userId },
    });
  }

  async updateProfile(userId: string, dto: UpdateProfileDto) {
    return this.prisma.user.update({
      where: { id: userId },
      data: {
        name: dto.name,
        email: dto.email,
        phone: dto.phone,
        location: dto.location,
        bio: dto.bio,
      },
      select: {
        id: true,
        name: true,
        email: true,
        phone: true,
        location: true,
        bio: true,
        role: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }

  async findPatients() {
    return this.prisma.user.findMany({
      where: {
        role: 'PATIENT',
      },
    });
  }

  async createUser(createUserDto: CreateUserDto, clinicaId?: string) {
    // Verificar si el email ya existe en la misma cl√≠nica
    const whereCondition = clinicaId 
      ? { email: createUserDto.email, clinicaId: clinicaId }
      : { email: createUserDto.email, clinicaId: null };

    const existingUser = await this.prisma.user.findFirst({
      where: whereCondition,
    });

    if (existingUser) {
      throw new ConflictException('El email ya est√° en uso en esta cl√≠nica');
    }

    // Generar contrase√±a autom√°ticamente (siempre, para mayor seguridad)
    const generatedPassword = PasswordGenerator.generateTempPassword();
    const hashedPassword = await bcrypt.hash(generatedPassword, 10);

    console.log(`üîê Contrase√±a generada para ${createUserDto.email}: ${generatedPassword}`);

    // Obtener permisos seg√∫n el rol
    const permisos = PermissionsService.getPermisosPorRol(createUserDto.tipo);
    const permisosString = PermissionsService.getPermisosAsString(permisos);

    // Crear el usuario
    const user = await this.prisma.user.create({
      data: {
        name: createUserDto.nombre,
        email: createUserDto.email,
        password: hashedPassword,
        role: createUserDto.tipo,
        phone: createUserDto.phone,
        clinicaId: clinicaId || null, // Asociar a cl√≠nica si se proporciona
        estado: 'pendiente', // Estado inicial como pendiente
        configuracion: permisosString, // Guardar permisos en configuracion
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        estado: true,
        createdAt: true,
        phone: true,
        clinicaId: true,
      },
    });

    // Enviar email de bienvenida con credenciales
    let emailResult: { success: boolean; error?: string } = { success: false, error: 'No se intent√≥ enviar' };
    try {
      console.log(`üìß Enviando email de bienvenida a ${createUserDto.email}...`);
      
      // Obtener nombre y URL de la cl√≠nica si hay clinicaId
      let clinicaName = 'Clinera'; // Nombre por defecto
      let clinicaUrl: string | undefined = undefined; // URL por defecto
      if (clinicaId) {
        try {
          const clinica = await this.prisma.clinica.findUnique({
            where: { id: clinicaId },
            select: { name: true, url: true }
          });
          if (clinica) {
            clinicaName = clinica.name;
            clinicaUrl = clinica.url;
          }
        } catch (error) {
          console.warn('No se pudo obtener la informaci√≥n de la cl√≠nica:', error);
        }
      }
      
      const emailSent = await this.emailService.sendWelcomeCredentialsEmail(
        createUserDto.email,
        generatedPassword,
        createUserDto.nombre,
        createUserDto.tipo,
        clinicaName
      );

      if (emailSent) {
        console.log(`‚úÖ Email de bienvenida enviado exitosamente a ${createUserDto.email}`);
        emailResult = { success: true };
      } else {
        console.error(`‚ùå Error al enviar email de bienvenida a ${createUserDto.email}`);
        emailResult = { success: false, error: 'Error al enviar email' };
        // No lanzamos error para no interrumpir la creaci√≥n del usuario
      }
    } catch (emailError) {
      console.error(`‚ùå Error inesperado al enviar email de bienvenida a ${createUserDto.email}:`, emailError);
      emailResult = { success: false, error: emailError.message || 'Error inesperado' };
      // No lanzamos error para no interrumpir la creaci√≥n del usuario
    }

    return {
      ...user,
      permisos,
      emailEnviado: emailResult.success,
      fechaEmailEnviado: emailResult.success ? new Date().toISOString() : null,
      emailError: emailResult.error,
      // No devolver la contrase√±a en la respuesta por seguridad
      message: emailResult.success 
        ? 'Usuario creado exitosamente. Se ha enviado un email con las credenciales de acceso.'
        : 'Usuario creado exitosamente, pero no se pudo enviar el email de bienvenida.',
    };
  }

  async createUserForClinica(clinicaUrl: string, createUserDto: CreateUserDto) {
    console.log(`üöÄ ===== INICIO SERVICIO createUserForClinica =====`);
    console.log(`üîç SERVICE: createUserForClinica llamado con clinicaUrl: ${clinicaUrl}`);
    console.log(`üîç SERVICE: DTO recibido:`, JSON.stringify(createUserDto, null, 2));
    console.log(`üîç SERVICE: Timestamp: ${new Date().toISOString()}`);
    
    try {
      console.log(`üîç SERVICE: Iniciando b√∫squeda de cl√≠nica...`);
      console.log(`üîç SERVICE: Buscando cl√≠nica con URL: ${clinicaUrl}`);
      
      // Buscar la cl√≠nica por URL (el par√°metro clinicaUrl es la URL de la cl√≠nica)
      console.log(`üîç SERVICE: Ejecutando query: SELECT * FROM "Clinica" WHERE url = '${clinicaUrl}'`);
      const clinica = await this.prisma.clinica.findUnique({
        where: { url: clinicaUrl },
      });
      
      console.log(`üîç SERVICE: Resultado de b√∫squeda de cl√≠nica:`, clinica ? 'ENCONTRADA' : 'NO ENCONTRADA');
      if (clinica) {
        console.log(`üîç SERVICE: Cl√≠nica encontrada - ID: ${clinica.id}, Name: ${clinica.name}, URL: ${clinica.url}`);
      }

      if (!clinica) {
        console.log(`‚ùå SERVICE: Cl√≠nica no encontrada: ${clinicaUrl}`);
        throw new NotFoundException(`Cl√≠nica con URL '${clinicaUrl}' no encontrada`);
      }

      console.log(`‚úÖ SERVICE: Cl√≠nica encontrada: ${clinica.name} (ID: ${clinica.id})`);

      // Verificar si el email ya existe en esta cl√≠nica espec√≠fica
      console.log(`üîç SERVICE: Verificando si email ${createUserDto.email} ya existe en cl√≠nica ${clinica.id}`);
      console.log(`üîç SERVICE: Ejecutando query: SELECT * FROM "User" WHERE email = '${createUserDto.email}' AND "clinicaId" = '${clinica.id}'`);
      
      const existingUser = await this.prisma.user.findFirst({
        where: { 
          email: createUserDto.email,
          clinicaId: clinica.id
        },
      });
      
      console.log(`üîç SERVICE: Resultado de b√∫squeda de usuario existente:`, existingUser ? 'ENCONTRADO' : 'NO ENCONTRADO');
      if (existingUser) {
        console.log(`üîç SERVICE: Usuario existente encontrado - ID: ${existingUser.id}, Email: ${existingUser.email}, Cl√≠nica: ${existingUser.clinicaId}`);
      }

      if (existingUser) {
        console.log(`‚ùå SERVICE: Email ya existe en esta cl√≠nica: ${createUserDto.email}`);
        throw new ConflictException('El email ya est√° en uso en esta cl√≠nica');
      }

      console.log(`‚úÖ SERVICE: Email disponible en esta cl√≠nica: ${createUserDto.email}`);

    // Log espec√≠fico para el email problem√°tico
    if (createUserDto.email === 'delfina.spais@oacg.cl') {
      console.log(`üîç DEBUG ESPEC√çFICO: Procesando email delfina.spais@oacg.cl`);
      console.log(`üîç DEBUG ESPEC√çFICO: Cl√≠nica ID: ${clinica.id}`);
      console.log(`üîç DEBUG ESPEC√çFICO: DTO completo:`, JSON.stringify(createUserDto, null, 2));
    }

    console.log(`üîç SERVICE: Generando contrase√±a autom√°ticamente...`);
    // Generar contrase√±a autom√°ticamente (siempre, para mayor seguridad)
    const generatedPassword = PasswordGenerator.generateTempPassword();
    const hashedPassword = await bcrypt.hash(generatedPassword, 10);

    console.log(`üîê SERVICE: Contrase√±a generada para ${createUserDto.email}: ${generatedPassword}`);

    console.log(`üîç SERVICE: Obteniendo permisos seg√∫n el rol: ${createUserDto.tipo}`);
    // Obtener permisos seg√∫n el rol
    const permisos = PermissionsService.getPermisosPorRol(createUserDto.tipo);
    const permisosString = PermissionsService.getPermisosAsString(permisos);
    console.log(`üîç SERVICE: Permisos obtenidos:`, permisos);
    console.log(`üîç SERVICE: Permisos como string: ${permisosString}`);

    // Log espec√≠fico para el email problem√°tico antes de crear
    if (createUserDto.email === 'delfina.spais@oacg.cl') {
      console.log(`üîç DEBUG ESPEC√çFICO: Antes de crear usuario con email delfina.spais@oacg.cl`);
      console.log(`üîç DEBUG ESPEC√çFICO: Datos a insertar:`, {
        name: createUserDto.nombre,
        email: createUserDto.email,
        role: createUserDto.tipo,
        phone: createUserDto.phone,
        clinicaId: clinica.id,
        estado: 'pendiente'
      });
    }

    console.log(`üîç SERVICE: Preparando datos para insertar en la base de datos...`);
    const userData = {
      name: createUserDto.nombre,
      email: createUserDto.email,
      password: hashedPassword,
      role: createUserDto.tipo,
      phone: createUserDto.phone,
      clinicaId: clinica.id,
      estado: 'pendiente',
      configuracion: permisosString,
    };
    console.log(`üîç SERVICE: Datos a insertar:`, JSON.stringify(userData, null, 2));

    console.log(`üîç SERVICE: Ejecutando INSERT en la base de datos...`);
    console.log(`üîç SERVICE: Query: INSERT INTO "User" (name, email, password, role, phone, "clinicaId", estado, configuracion) VALUES (...)`);
    
    // Crear el usuario asociado a la cl√≠nica correcta
    const user = await this.prisma.user.create({
      data: {
        name: createUserDto.nombre,
        email: createUserDto.email,
        password: hashedPassword,
        role: createUserDto.tipo,
        phone: createUserDto.phone,
        clinicaId: clinica.id, // Usar el ID de la cl√≠nica encontrada por URL
        estado: 'pendiente', // Estado inicial como pendiente
        configuracion: permisosString, // Guardar permisos en configuracion
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        estado: true,
        createdAt: true,
        phone: true,
        clinicaId: true,
      },
    });

    // Enviar email de bienvenida con credenciales
    let emailResult: { success: boolean; error?: string } = { success: false, error: 'No se intent√≥ enviar' };
    try {
      console.log(`üìß Enviando email de bienvenida a ${createUserDto.email}...`);
      
      const emailSent = await this.emailService.sendWelcomeCredentialsEmail(
        createUserDto.email,
        generatedPassword,
        createUserDto.nombre,
        createUserDto.tipo,
        clinica.name
      );

      if (emailSent) {
        console.log(`‚úÖ Email de bienvenida enviado exitosamente a ${createUserDto.email}`);
        emailResult = { success: true };
      } else {
        console.error(`‚ùå Error al enviar email de bienvenida a ${createUserDto.email}`);
        emailResult = { success: false, error: 'Error al enviar email' };
        // No lanzamos error para no interrumpir la creaci√≥n del usuario
      }
    } catch (emailError) {
      console.error(`‚ùå Error inesperado al enviar email de bienvenida a ${createUserDto.email}:`, emailError);
      emailResult = { success: false, error: emailError.message || 'Error inesperado' };
      // No lanzamos error para no interrumpir la creaci√≥n del usuario
    }

    // Intentar registrar el usuario en mensapi (no bloquea si falla)
    let mensapiResult: any = null;
    try {
      mensapiResult = await this.mensapiIntegration.registerUser({
        name: createUserDto.nombre,
        email: createUserDto.email,
        password: generatedPassword, // Usar la contrase√±a generada
        phone: createUserDto.phone,
      }, clinica.mensapiServiceEmail || undefined, clinica.mensapiServicePassword || undefined);
    } catch (error) {
      // Log del error pero no fallar la creaci√≥n del usuario
      console.warn('Error registrando usuario en mensapi:', error.message);
    }

    return {
      ...user,
      permisos,
      clinica: {
        id: clinica.id,
        name: clinica.name,
        url: clinica.url,
      },
      emailEnviado: emailResult.success,
      fechaEmailEnviado: emailResult.success ? new Date().toISOString() : null,
      emailError: emailResult.error,
      mensapi: mensapiResult ? {
        registered: true,
        accessToken: mensapiResult.content.accessToken,
        refreshToken: mensapiResult.content.refreshToken,
      } : {
        registered: false,
        error: 'No se pudo registrar en mensapi',
      },
    };
    } catch (error) {
      console.error(`üöÄ ===== ERROR EN SERVICIO createUserForClinica =====`);
      console.error('‚ùå SERVICE: Error en createUserForClinica:', error);
      console.error('‚ùå SERVICE: Error message:', error.message);
      console.error('‚ùå SERVICE: Error stack:', error.stack);
      console.error('‚ùå SERVICE: Error name:', error.name);
      console.error('‚ùå SERVICE: Error code:', error.code);
      console.error('‚ùå SERVICE: Error cause:', error.cause);
      console.error('‚ùå SERVICE: Error timestamp:', new Date().toISOString());
      console.error(`üöÄ ===== FIN ERROR EN SERVICIO =====`);
      throw error;
    }
  }

  async findAllForClinica(clinicaUrl: string) {
    // Buscar la cl√≠nica por URL
    const clinica = await this.prisma.clinica.findUnique({
      where: { url: clinicaUrl },
    });

    if (!clinica) {
      throw new NotFoundException(`Cl√≠nica con URL '${clinicaUrl}' no encontrada`);
    }

    return this.prisma.user.findMany({
      where: { clinicaId: clinica.id },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        estado: true,
        createdAt: true,
        phone: true,
        clinicaId: true,
        configuracion: true,
      },
    });
  }

  async findMeForClinica(userId: string, clinicaUrl: string) {
    // Buscar la cl√≠nica por URL
    const clinica = await this.prisma.clinica.findUnique({
      where: { url: clinicaUrl },
    });

    if (!clinica) {
      throw new NotFoundException(`Cl√≠nica con URL '${clinicaUrl}' no encontrada`);
    }

    const user = await this.prisma.user.findUnique({
      where: { 
        id: userId,
        clinicaId: clinica.id, // Verificar que el usuario pertenece a esta cl√≠nica
      },
    });

    if (!user) {
      throw new NotFoundException('Usuario no encontrado en esta cl√≠nica');
    }

    return user;
  }

  async updateProfileForClinica(userId: string, clinicaUrl: string, dto: UpdateProfileDto) {
    // Buscar la cl√≠nica por URL
    const clinica = await this.prisma.clinica.findUnique({
      where: { url: clinicaUrl },
    });

    if (!clinica) {
      throw new NotFoundException(`Cl√≠nica con URL '${clinicaUrl}' no encontrada`);
    }

    return this.prisma.user.update({
      where: { 
        id: userId,
        clinicaId: clinica.id, // Verificar que el usuario pertenece a esta cl√≠nica
      },
      data: {
        name: dto.name,
        email: dto.email,
        phone: dto.phone,
        location: dto.location,
        bio: dto.bio,
      },
      select: {
        id: true,
        name: true,
        email: true,
        phone: true,
        location: true,
        bio: true,
        role: true,
        createdAt: true,
        updatedAt: true,
      },
    });
  }

  async findPatientsForClinica(clinicaUrl: string) {
    // Buscar la cl√≠nica por URL
    const clinica = await this.prisma.clinica.findUnique({
      where: { url: clinicaUrl },
    });

    if (!clinica) {
      throw new NotFoundException(`Cl√≠nica con URL '${clinicaUrl}' no encontrada`);
    }

    return this.prisma.user.findMany({
      where: {
        role: 'PATIENT',
        clinicaId: clinica.id,
      },
    });
  }

  async updateUserForClinica(clinicaUrl: string, userId: string, dto: UpdateUserDto) {
    // Buscar la cl√≠nica por URL
    const clinica = await this.prisma.clinica.findUnique({
      where: { url: clinicaUrl },
    });

    if (!clinica) {
      throw new NotFoundException(`Cl√≠nica con URL '${clinicaUrl}' no encontrada`);
    }

    // Verificar que el usuario existe y pertenece a la cl√≠nica
    const existingUser = await this.prisma.user.findFirst({
      where: {
        id: userId,
        clinicaId: clinica.id,
      },
    });

    if (!existingUser) {
      throw new NotFoundException('Usuario no encontrado en esta cl√≠nica');
    }

    // Si se est√° cambiando el email, verificar que no est√© en uso por otro usuario en la misma cl√≠nica
    if (dto.email && dto.email !== existingUser.email) {
      const emailExists = await this.prisma.user.findFirst({
        where: {
          email: dto.email,
          clinicaId: clinica.id, // Solo verificar en la misma cl√≠nica
          id: { not: userId }, // Excluir el usuario actual
        },
      });

      if (emailExists) {
        throw new ConflictException('El email ya est√° en uso por otro usuario en esta cl√≠nica');
      }
    }

    // Preparar datos para actualizar
    const updateData: any = {};
    
    if (dto.name !== undefined) updateData.name = dto.name;
    if (dto.email !== undefined) updateData.email = dto.email;
    if (dto.phone !== undefined) updateData.phone = dto.phone;
    if (dto.role !== undefined) updateData.role = dto.role;
    if (dto.estado !== undefined) updateData.estado = dto.estado;
    if (dto.permisos !== undefined) updateData.configuracion = JSON.stringify(dto.permisos);

    // Actualizar el usuario
    const updatedUser = await this.prisma.user.update({
      where: { id: userId },
      data: updateData,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        estado: true,
        createdAt: true,
        phone: true,
        clinicaId: true,
        configuracion: true,
      },
    });

    return updatedUser;
  }

  async deleteUserForClinica(clinicaUrl: string, userId: string) {
    // Buscar la cl√≠nica por URL
    const clinica = await this.prisma.clinica.findUnique({
      where: { url: clinicaUrl },
    });

    if (!clinica) {
      throw new NotFoundException(`Cl√≠nica con URL '${clinicaUrl}' no encontrada`);
    }

    // Verificar que el usuario existe y pertenece a la cl√≠nica
    const existingUser = await this.prisma.user.findFirst({
      where: {
        id: userId,
        clinicaId: clinica.id,
      },
    });

    if (!existingUser) {
      throw new NotFoundException('Usuario no encontrado en esta cl√≠nica');
    }

    // Eliminar el usuario
    await this.prisma.user.delete({
      where: { id: userId },
    });

    return { message: 'Usuario eliminado exitosamente' };
  }

  async debugCheckEmail(clinicaUrl: string, email: string) {
    try {
      console.log(`üîç DEBUG: Verificando email ${email} para cl√≠nica ${clinicaUrl}`);
      
      // Buscar la cl√≠nica
      const clinica = await this.prisma.clinica.findUnique({
        where: { url: clinicaUrl },
      });

      if (!clinica) {
        return { error: `Cl√≠nica con URL '${clinicaUrl}' no encontrada` };
      }

      console.log(`‚úÖ Cl√≠nica encontrada: ${clinica.name} (ID: ${clinica.id})`);

      // Buscar usuarios con ese email en esa cl√≠nica
      const usersInClinica = await this.prisma.user.findMany({
        where: { 
          email: email,
          clinicaId: clinica.id
        },
      });

      // Buscar usuarios con ese email en cualquier cl√≠nica
      const usersAnywhere = await this.prisma.user.findMany({
        where: { 
          email: email
        },
      });

      // Buscar usuarios con ese email sin cl√≠nica
      const usersWithoutClinica = await this.prisma.user.findMany({
        where: { 
          email: email,
          clinicaId: null
        },
      });

      return {
        clinica: {
          id: clinica.id,
          name: clinica.name,
          url: clinica.url
        },
        email: email,
        usersInClinica: usersInClinica.length,
        usersAnywhere: usersAnywhere.length,
        usersWithoutClinica: usersWithoutClinica.length,
        canCreate: usersInClinica.length === 0,
        details: {
          inClinica: usersInClinica.map(u => ({ id: u.id, clinicaId: u.clinicaId, role: u.role })),
          anywhere: usersAnywhere.map(u => ({ id: u.id, clinicaId: u.clinicaId, role: u.role })),
          withoutClinica: usersWithoutClinica.map(u => ({ id: u.id, clinicaId: u.clinicaId, role: u.role }))
        }
      };
    } catch (error) {
      console.error('‚ùå Error en debugCheckEmail:', error);
      return { error: error.message };
    }
  }
}
